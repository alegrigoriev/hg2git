# hg-to-git: Mercurial repository reader and convertor to Git

This Python program allows you to read and analyze a Mercurial (HG) repository,
and also optionally convert it to Git repository.

Running the program
-------------------

The program is invoked by the following command line:

`python hg-to-git.py <repository path> [<options>]`

The following command line options are supported:

`--version`
- show program version.

`--config <XML config file>` (or `-c <XML config file>`)
- specify the configuration file for conversion options.
See [XML configuration file](#xml-config-file) chapter.

`--log <log file>`
- write log to a file. By default, the log is sent to the standard output.

`--end-revision <REV>`
- makes the dump stop after the specified revision number.

`--quiet`
- suppress progress indication (number of revisions processed, time elapsed).
By default, the progress indication is active on a console,
but is suppressed if the standard error output is not recognized as console.
If you don't want progress indication on the console, specify `--quiet` command line option.

`--progress[=<period>]`
- force progress indication, even if the standard error output is not recognized as console,
and optionally set the update period in seconds as a floating point number.
For example, `--progress=0.1` sets the progress update period 100 ms.
The default update period is 1 second.

`--branches <branches namespace>`
- use this directory name as the root directory for branches. The default is **refs/heads/**.
This value is also assigned to **$Branches** variable to use for substitutions in the XML config file.

`--tags <tags namespace>`
- use this directory name as the root directory for tags. The default is **refs/tags/**.
This value is also assigned to **$Tags** variable to use for substitutions in the XML config file.

`--no-default-config`
- don't use default namespaces for branches and tags. This option doesn't affect default variable assignments.

`--verbose={dump|revs|commits|all|dump_all}`
- dump additional information to the log file.

	`--verbose=dump`
	- dump revisions to the log file.

	`--verbose=revs`
	- log the difference from each previous revision, in form of added, deleted and modified files and attributes.
This doesn't include file diffs.
	`--verbose=dump_all`
	- dump all revisions, even empty revisions without any change operations.
By default, `--verbose=dump` and `--verbose=all` don't dump empty revisions.

	`--verbose=commits` 
	- issue `git show --raw --parents --no-decorate --abbrev-commit` for each commit made during conversion.

	`--verbose=all`
	- same as `--verbose=dump --verbose=revs --verbose=commits`

`--project <project name filter>`
- selects projects to process. This option can appear multiple times. See [Project filtering](#project-filtering).

`--target-repository <target Git repository path>`
- Specifies path to the target Git repository.
The repository should be previously initialized by a proper `git init` command.
The program will not delete existing refs, only override them as needed.

`--decorate-commit-message <tagline type>`
- tells the program to add a tagline to each commit message, depending on `<tagline type>`.
At this time, the only `<tagline type>` supported is `revision-id`,
which tells the program to add `HG-revision: <rev>` taglines with Mercurial revision number to each commit.
By default, the commit messages are undecorated.

`--convert-hgignore`
- convert `.hgignore` files to `.gitignore`. See [.hgignore to .gitignore conversion](#convert-hgignore) for more details.

`--convert-hgeol`
- convert `.hgeol` files to `.gitattributes`. See [.hgeol to .gitattributes conversion](#convert-hgeol) for more details.

`--create-revision-refs`
- generate a ref (symbolic reference) for each commit, using a default mapping.
For most commits on branches the ref is written in form `refs/revisions/<branch name>/r<rev id>`.
For commits on tag "branches", the ref is written in form `refs/revisions/tags/<tag name>/r<rev id>`.
Note that if a tag is set on a commit belonging to a branch, a separate revision ref is not made for it.
This option doesn't affect revision refs generated by an explicit `<RevisionRef>` specification.

`--authors-map <authors-map.json file>`
- specifies a JSON file to map Mercurial usernames to Git author/committer names and emails,
see [Mapping Mercurial usernames](#Mapping-HG-usernames) section.

`--make-authors-map <authors-map.json file>`
- specifies filename to write a template JSON file for mapping Mercurial usernames to Git author/committer names and emails,
see [Mapping Mercurial usernames](#Mapping-HG-usernames) section.

XML configuration file{#xml-config-file}
======================

Mapping of Mercurial branches Git branches, and other global and per-branch settings,
is described by an XML configuration file.
This file is specified by `--config` command line option.

The file consists of the root node `<Projects>`, which contains a single section `<Default>` and a number of sub-sections `<Project>`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<Projects xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation=". hg-config.xsd">
	<Default>
		<!-- default settings go here -->
	</Default>
	<Project Name="*" Branch="*">
		<!-- per-project settings go here -->
	</Project>
</Projects>
```

`xsi:schemaLocation` attribute refers to `hg-config.xsd.xsd` schema file provided with this repository,
which can be used to validate the XML file in some editors, for example, in Microsoft Visual Studio.

Wildcard (glob) specifications in the config file{#config-file-wildcard}
-------------------------------------------------

Paths and other path-like values in the configuration file can contain wildcard (glob) characters.
In general, these wildcards follow Unix/Git conventions. The following wildcards are recognized:

'`?`' - matches any character;

'`*`' - matches a sequence of any characters, except for slash '`/`'. The matched sequence can be empty.

'`/*/`' - matches a non-empty sequence of any (except for slash '`/`') characters between two slashes.

'`*/`' in the beginning of a path - matches a non-empty sequence of any (except for slash '`/`') characters before the first slash.

'`**`' - matches a sequence of any characters, _including_ slashes '`/`', **or** an empty string.

'`**/`' - matches a sequence of any characters, _including_ slashes '`/`', ending with a slash '`/`', **or** an empty string.

`{<match1>,...}` - matches one of the comma-separated patterns (each of those patterns can also contain wildcards).

Note that `[range...]` character range Unix glob specification is not supported.

As in Git, a glob specification which matches a single path component (with or without a trailing slash) matches such a component at any position in the path.
If a trailing slash is present, only directory-like components can match.
If there's no trailing slash, both directory- and file-like components can match the given glob specification. Thus, a single '`*`' wildcard matches any filename.
If a glob specification can match multiple path components, it's assumed it begins with a slash '`/`', meaning the match starts with the beginning of the path.

In many places, multiple wildcard specifications can be present, separated by a semicolon '`;`'.
They are tested one by one, until one matches.
In such a sequence, a negative wildcard can be present, prefixed with a bang character '`!`'.
If a negative wildcard matches, the whole sequence is considered no-match.
You can use such negative wildcards to carve exceptions from a wider wildcard.
If all present wildcards are negative, and none of them matches, this considered a positive match, as if there was a "`**`" match all specification in the end.

Variable substitutions in the config file{#variable-substitutions}
-----------------------------------------

You can assign a value to a variable, and have that value substituted whenever a string contains a reference to that variable.

The assignment is done by `<Vars>` section, which can appear under `<Default>` and `<Project>` sections. It has the following format:

```
		<Vars>
			<variable_name>value</variable_name>
		</Vars>
```

The following default variables are preset:

```xml
		<Vars>
			<Branches>refs/heads/</Branches>
			<Tags>refs/tags/</Tags>
		</Vars>
```

They can be overridden explicitly in `<Default>` and `<Project>` sections,
and/or by the command line options `--branches` and `--tags`.

For the variable substitution purposes, the sections are processed in order,
except for the specifications injected from `<Default>` section into `<Project>`.
All `<Vars>` definitions from `<Default>` are processed before all sections in `<Project>`.

For substitution, you refer to a variable as `$<variable name>`,
for example `$Trunk`, or `${<variable name>}`, for example `${Branches}`.
Another acceptable form is `$(<variable name>)`, for example `$(UserBranches)`.
You have to use the form with braces or parentheses
when you need to follow it with an alphabetical character, such as `${MapTrunkTo}1`.

Note that if a variable value is a list of semicolon-separated strings, like `users/branches;branches/users`,
its substitution will match one of those strings,
as if they were in a `{}` wildcard, like `{users/branches,branches/users}`.

A variable definition can refer to other variables. Circular substitutions are not allowed.

The variable substitution is done when the XML config sections are read.
When another `<Vars>` section is encountered, it affects the sections that follow it.

Ref character substitution{#ref-character-substitution}
--------------------------

Certain characters are not allowed in Git refnames.
The program allows to map invalid characters to allowed ones. The remapping is specified by `<Replace>` specification:

```xml
		<Replace>
			<Chars>source character</Chars>
			<With>replace with character</With>
		</Replace>
```

This specification is allowed in `<Default>` and `<Project>` sections.
All `<Replace>` definitions from `<Default>` are processed before all sections in `<Project>`.

Example:

```xml
		<Replace>
			<Chars> </Chars>
			<With>_</With>
		</Replace>
```

This will replace spaces with underscores.

`<Default>` section{#default-section}
---------------

A configuration file can contain zero or one `<Default>` section under the root node.
This section contains mappings and variable definitions to be used as defaults for all projects.
In absence of `<Project>` sections, the `<Default>` section is used as a default project.

`<Default>` section is merged into beginning of each `<Project>` section,
except for `<MapBranch>` specifications,
which are merged _after_ the end of each `<Project>` section.

`InheritDefault="No"` attribute in the `<Default>` section header suppresses
inheritance from the hardcoded configuration.

`InheritDefaultMappings="No"` suppresses inheritance of default `<MapBranch>`
mappings.

`<Vars>` and `<Replace>` specifications are always inherited from the hardcoded defaults
or passed from the command line.

`<Project>` section{#project-section}
---------------

A configuration file can contain zero or more `<Project>` sections under the root node.
This section isolates mappings, variable definitions, and other setting to be used together.

A `<Project>` section can have optional `Name` and `Branch` attributes.

If supplied, `Name` attribute values must be unique: two `<Project>` sections cannot have same name.

The `Branch` value filters the branches to be processed with this `<Project>`.
Its value can be one or more wildcards (glob) specifications, separated by semicolons.

`InheritDefault="No"` attribute in a `<Project>` or `<Default>` section suppresses
inheritance from its default (from hardcoded config or from `<Default>`
section).

`InheritDefaultMappings="No"` suppresses inheritance of default `<MapBranch>`
mappings.

`<Vars>` and `<Replace>` specifications are always inherited from the hardcoded defaults
or passed from the command line. Only their overrides in `<Default>` section will get ignored.

`<Project>` sections with `ExplicitOnly="Yes"` attribute are only used if explicitly selected
by `--project` command line option.

If a `<Project>` section relies on another project section,
for example, it merges paths from another project, specify such requirement with
`NeedsProjects="comma,separated,list"` attribute.

Branch to Ref mapping{#branch-mapping}
-------------------

Unlike Git, Mercurial branches don't live in a `refs/heads/` namespace.
Multiple history lines for one branch can be present and active in the repository.
Thus, the program needs to be told how to map directories to Git refs.

This program provides a default mapping of a branch name to a ref, by prepending `refs/heads/` to a branch name.

Non-default mapping allows to handle more complex cases.

You can map a branch name matching the specified pattern, into a specific Git ref,
built by substitution from the original name. This is done by `<MapBranch>` sections in `<Project>` or `<Default>` sections:

```xml
	<Project>
		<MapBranch>
			<Branch>branch matching specification</Branch>
			<Refname>ref substitution string</Refname>
			<!-- optional: -->
			<RevisionRef>revision ref substitution</RevisionRef>
		</MapBranch>
	</Project>
```

Here, `branch matching specification` is a glob (wildcard) match specification to match the Mercurial branch name,
`<Refname>` is the refname substitution specification to make Git branch refname for this branch,
and the optional `<RevisionRef>` substitution specification makes a root for revision refs for commits made on this branch.
If `--create-revision-refs` is present in the command line, an implicit `<RevisionRef>` mapping
will be added, if not present.

The program replaces special variables and specifications in `ref substitution string`
with strings matching the wildcard specifications in `branch matching specification`.
During the pattern match, each explicit wildcard specification, such as '`?`', '`*`', '`**`', '`{pattern...}`',
assigns a value to a numbered variable `$1`, `$2`, etc.
The substitution string can refer to those variables as `$1`, `$2`, or as `${1}`, `$(2)`, etc.
Explicit brackets or parentheses are required if the variable occurrence has to be followed by a digit.
If the substitutions are in the same order as original wildcards, you can also refer to them as '`*`', '`**`'.

Note that you can only refer to wildcards in the initial match specification string,
not to wildcards inserted to the match specification through variable substitution.

Every time a new branch is created in a repository,
the program tries to map its name into a symbolic reference AKA ref.

`<MapBranch>` definitions are processed in their order in the config file in each `<Project>`.
First `<Project>` definitions are processed, then definitions from `<Default>`,
and then default mappings described above (unless they are suppressed by `--no-default-config` command line option).

The first `<MapBranch>` with `<Branch>` matching the branch name will define which Git "branch" this directory belongs to.

The target refname in `<Refname>` specification is assumed to begin with `refs/` prefix.
If the `refs/` prefix is not present, it's implicitly added.

If a refname produced for a branch collides with a refname for a different branch,
the program will try to create an unique name by appending `__<number>` to it.

If `<Refname>` specification is omitted, this name is explicitly unmapped from creating a branch.

The program can create a special ref for each commit it makes, to map Mercurial commits to Git commits.
An optional `<RevisionRef>` specification defines how the revision ref name root is formatted.
If `--create-revision-refs` is present in the command line, an implicit mapping will make
refnames for branches (Git ref matching `refs/heads/<branch name>`) as `refs/revisions/<branch name>/r<rev number>`.

Some Mercurial branches may not match any of the `<MapBranch>` directive,
and thus remain not mapped to any Git branch.
The program prints list of these branches to the log file.

Tag to Ref mapping{#tag-mapping}
-------------------

Unlike Git, Mercurial tags don't live in a `refs/tags/` namespace. They are tracked with `.hgtags` file.
Thus, the program needs to be told how to map tags to Git refs.

This program provides a default mapping of a tag name to a ref, by prepending `refs/tags/` to a tag name.

Non-default mapping allows to handle more complex cases.

You can map a tag name matching the specified pattern, into a specific Git ref,
built by substitution from the original name. This is done by `<MapTag>` sections in `<Project>` or `<Default>` sections:

```xml
	<Project>
		<MapTag>
			<Tag>tag matching specification</Tag>
			<Refname>ref substitution string</Refname>
		</MapTag>
	</Project>
```

Here, `tag matching specification` is a glob (wildcard) match specification to match the Mercurial branch name,
`<Refname>` is the refname substitution specification to make Git branch refname for this branch,
and the optional `<RevisionRef>` substitution specification makes a root for revision refs for commits made on this branch.

Every time a new branch is created in a repository,
the program tries to map its path into a symbolic reference AKA ref.

`<MapTag>` definitions are processed in their order in the config file in each `<Project>`.
First `<Project>` definitions are processed, then definitions from `<Default>`,
and then default mappings described above (unless they are suppressed by `--no-default-config` command line option).

The first `<MapTag>` with `<Branch>` matching the tag name will define which Git "branch" this directory belongs to.
The rest of the path will be a subdirectory in the branch worktree.

The target refname in `<Refname>` specification is assumed to begin with `refs/` prefix.
If the `refs/` prefix is not present, it's implicitly added.

If a refname produced for a tag collides with a refname for a different tag,
the program will try to create an unique name by appending `__<number>` to it.

If `<Refname>` specification is omitted, this directory and all its subdirectories are explicitly unmapped from creating a branch. 

Project filtering{#project-filtering}
-----------------

You can select to process only some projects - enable only selected `<Project>` sections in the XML configuration file.
Projects to process are selected by specifying `--project <project name filter>` option(s) in the command line.

Multiple `--project` options can be supplied in the command line.
The option value can contain multiple project name filters, separated by commas.

If a filter is prefixed with an exclamation mark '`!`',
this pattern excludes projects (negative match).
Note that in *bash* command line, '`!`' character needs to be single-quoted as "`'!'`"
to prevent history expansion:

`--project '!'<excluded project pattern>`

Git refname remapping
-----------------

The program allows to remap the created refnames further by using `<MapRef>` specification:

```xml
	<Project>
		<MapRef>
			<Ref>ref matching specification</Ref>
			<NewRef>ref substitution string</NewRef>
		</MapRef>
	</Project>
```

The matching and substitution rules are similar to `<MapBranch>` specification.
The `ref matching specification` needs to match the full source refname.
All `<MapRef>` definitions from `<Default>` are processed *after* all sections in `<Project>`.

If `<NewRef>` is omitted, the ref will not be issued into the target Git repository.
This allows to delete the unwanted refs, such as obsolete branches, partially merged to the trunk.

Note that character substitution (specified by `<Replace>`) is done after refname remapping.

Commit message editing{#Commit-message-editing}
----------------------

You can fix commit messages if you don't like what's in the original revisions.

The message editing is done by `<EditMsg>` specifications, which can be present at the project level,
or in `<MapBranch>` specifications.

```xml
	<Project>
		<EditMsg Final="yes" Revs="revisions" RevIds="Revision IDs" Max="max substitutions">
			<Match>regular expression</Match>
			<Replace>substitution</Replace>
		</EditMsg>
		<MapBranch>
			...
			<EditMsg Final="yes" Revs="revisions" RevIds="Revision IDs" Max="max substitutions">
				<Match>regular expression</Match>
				<Replace>substitution</Replace>
			</EditMsg>
		</MapBranch>
	</Project>
```

`<Match>` specification contains a regular expression (regex) in format supported by Python `re` module.
The match is performed in `MULTILINE` mode, where `^` character matches start of each line of the whole message,
and `$` also matches end of each line (before a newline).
Use `\A` to match the start of the message, and `\Z` to match the end.

To match a period, don't forget escape it with a backslash, as `\.`.

Keep in mind that `.` normally matches all *except* a newline. To have it match everything, including a newline,
enable DOTALL match mode by enclosing the pattern in `(?s:` `pattern` `)`.

To replace the whole message, omit the `<Match>` specification altogether.

`<Replace>` specification contains a substitution string in format expected by `re.sub()` function.
Note that backslashes don't have a special meaning in XML text,
but ampersand, quote, apostrophe, "less" and "greater" characters
needs to be replaced with special sequences: `&amp;`, `&quot;`, `&apos;`, `&lt;`, `&gt;`.

Multiple `<EditMsg>` specifications can be present.
The program first performs match and replacement for specifications in `<MapBranch>` block for the current branch,
then for specifications in `<Project>` and `<Default>` blocks.

`Final="yes"` attribute in the `<EditMsg>` specification tells the program to stop processing other
such specification if this one matched the message and performed a substitution.
If `Final="yes"` attribute is not present (or the value does not represent "true"),
the program continues to match and replace the given commit message after a replacement was done.

`Revs="revisions"` specifies comma-separated numerical revision numbers or revision ranges as `start-end`,
to which this specification applies.

`RevIds="revision IDs"` specifies comma- or whitespace- separated symbolic revision IDs,
to which this specification applies.

`Max="max substitutions"` limits number of times the substitution will be made in a single commit message.
If not present, or `"0"`, the pattern substitution will not be limited.

Note that you can produce different commit messages for commits on same revision in different branches,
by using different `<EditMsg>` specifications in separate `<MapBranch>` blocks for those branches.

If the resulting non-blank message starts with two newlines,
the program will insert an added/changed/deleted/renamed files summary as the commit subject line.
If you want to add this automatically every time the original message starts from multiple
non-blank lines, use the following edit specification:

```xml
	<Project>
		<EditMsg Final="yes" Revs="revisions" RevIds="Revision IDs" Max="max substitutions">
			<Match>\A(.+\n.+$)</Match>
			<Replace>\n\n\1</Replace>
		</EditMsg>
	</Project>
```

Handling of empty commit messages
---------------------------------

Mercurial allows empty commit messages. An empty message may also be produced by [commit message editing](#Commit-message-editing).

The program will generate a commit message describing all added, deleted, changed, renamed files.

Mercurial history tracking{#hg-history-tracking}
----------------

The program makes a new Git commit on a branch when there are changes in its directory tree.
The commit message, timestamps and author/committer are taken from the commit information.
Mercurial doesn't have a distinction between author and committer.

Single branch merges are fast-forwarded, when possible.

Handling of deleted branches
----------------------------

In Mercurial, a branch can be deleted, terminating its history.

**hg-to-git** program handles these cases by assigning a ref with `_deleted@r<rev>` suffix,
but only if that point haven't been merged into another branch.
You can drop these refs, using `MapRef` specifications.

Automatic deletion of merged branches
-------------------------------------

The program can automatically delete a branch (do not write a ref for it) if it's been merged to another branch.
To enable this behavior, add `DeleteIfMerged="Yes"` attribute to `<MapBranch>` section tag:

```xml
	<Project>
		<MapBranch DeleteIfMerged="Yes">
			........
		</MapBranch>
	</Project>
```

Note that there's no support for such attribute at `<Project>` level.

Injection of files to branch tree
---------------------------------

The program allows you to inject files, such as `.gitattributes`, `.gitignore`, `.editorconfig` to the whole history of branches.
Injection is requested by adding `<InjectFile>` directive to `<Project>` or to `<Default>`,
which can either use immediate data, or load data from a file.

`<InjectFile>` specification injects a file relative to branch worktree.

```xml
	<Project>
		<!-- Use file data -->
		<!-- Branch attribute is optional -->
		<InjectFile Path="<file path>" File="<source file path>" Branch="<branch filter globspec>" />
		<!-- Use immediate data -->
		<InjectFile Path="<file path>" Branch="<branch filter globspec>">File data
</InjectFile>
	</Project>
```

Here, the mandatory `Path` attribute specified the injected file pathname,
relative to the branch worktree root.

For example, to inject `.gitignore` to the root directory of a branch, specify `Path=".gitignore"`.

Optional `Branch` attribute filters which branches are subject to injection of this file.
The attribute value is a glob specification to match the branch name in the Mercurial repository.

`<AddFile>` adds or replaces a file at the specified revision,
equivalent to a file being added or modified in the HG repository at the revision:

```xml
	<Project>
		<!-- Use file data -->
		<AddFile Path="<file path in HG repo>"
				File="<source file path>"
				RevId="<add/replace at revision ID>" />
		<!-- Use immediate data -->
		<AddFile Path="<file path in HG repo>"
				Rev="<add/replace at revision>">File data
</AddFile>
	</Project>
```

A file injected at one revision can be overridden by another file injected at different revision.
This directive can also override a file which was previously present in a repository.

`Rev="revision"` specifies the revision number at which the file is to be added.
`<RevId>revision ID</RevId>` specifies the revision string at which the file is to be added.
Only one `<Rev>` or `<RevId>` specification can be present.

`<InjectFile>` specification can also be present inside `<MapBranch>` section:

```xml
	<Project>
		<MapBranch>
			<!-- Use file data -->
			<!-- Branch attribute is optional -->
			<InjectFile Path="<file path>" File="<source file path>" Branch="<branch filter globspec>" />
			<!-- Or use immediate data -->
			<InjectFile Path="<file path>" Branch="<branch filter globspec>">File data
</InjectFile>
		</MapBranch>
	</Project>
```

In this case, the `<InjectFile>` directive applies only to branches mapped by this `<MapBranch>` section.

If data is to be loaded from a file specified by `File="<source file path>"` attribute,
it's committed as is (with possible conversion defined by implicit and explicit EOL conversion rules).
Note that the source file path is relative to the directory of this XML configuration file.

If immediate data is used, keep in mind the text is used exactly as included
between opening and closing XML tags, converted to UTF-8 encoding.

If a `.gitattributes` file is injected, this file will be used by Git during conversion from Mercurial revisions,
for EOL conversion and optionally encoding conversion (`working-tree-encoding` attribute).

WARNING: Git may leave lone CR (carriage return) characters as is during the conversion.

`.hgignore` to `.gitignore` conversion {#convert-hgignore}
----------------------

`--convert-hgignore` command line option enables conversion of `.hgignore` files to `.gitignore`.

There are two major differences between `.hgignore` and `.gitignore`.

1. By default, Mercurial processes `.hgignore` in the repository root only.
`.hgignore` files in subdirectories must be referred by `subinclude` lines in the root `.hgignore`.
A file with `.hgignore` syntax can also be included by an `include` directive.

	With Git, all `.gitignore` files in the root and subdirectories are processed.
There's no need to explicitly point to files in subdirectories.
2. `.hgignore` can contain regular expressions and "glob" patterns.
"glob" patterns can be "rooted" - relative to the `.hgignore` file location, or "non-rooted" - referring to
any subdirectory.

	`.gitignore` contains "glob" patterns only, which are "rooted",
except for single-component patterns in form "*filename*" or "*directory/*".

If `--convert-hgignore` command line option is present, the program converts all `.hgignore` files to `.gitignore`.
`subinclude` and `include` directives are ignored.
Regular expression patterns are converted to the equivalent glob patterns, when possible.
If the program is unable to convert a regular expression, it emits a warning line to the generated `.gitignore` file.
Rooted and non-rooted glob patterns are converted to `.gitignore` style patterns.
If the program is unable to convert a glob pattern, it emits a warning line to the generated `.gitignore` file.

If both `.hgignore` and `.gitignore` are present in a directory,
`.hgignore` conversion result will overwrite `.gitignore`. When a revision changes `.gitignore` only,
it overwrites the previous conversion result.
If `.gitignore` gets deleted, the file produced from `.hgignore` is restored.

The user needs to review the resulting file and make necessary correction in future commits,
or by manually injecting the correct file at the appropriate revisions,
by using `<AddFile>` directives in the configuration file.

`.hgeol` to `.gitattributes` conversion {#convert-hgeol}
----------------------

`--convert-hgeol` command line option enables conversion of `.hgeol` files to `.gitattributes`.

There are a few major differences between `.hgeol` and `.gitattributes`:

1. By default, Mercurial processes `.hgeol` in the repository root only.
There's no facility to include a subdirectory `.hgeol`.

	With Git, all `.gitattributes` files in the root and subdirectories are processed.

2. `.hgeol` contains "glob" patterns, which are always "rooted" - relative to the `.hgeol` file location.

	`.gitattributes` contains "glob" patterns only, which are "rooted",
except for single-component patterns in form "*filename*" or "*directory/*".

3. Mercurial support specification for the repository (stored) representation of files.

	Git always stores text files with LF line delimiters.

If `--convert-hgeol` command line option is present, the program converts the root `.hgeol` file to `.gitattributes`.
Rooted glob patterns are converted to `.gitattributes` style patterns.
If the program is unable to convert a glob pattern, it emits a warning line to the generated `.gitattributes` file.

If both `.hgeol` and `.gitattributes` are present in the root directory,
`.hgeol` conversion result will overwrite `.gitattributes`. When a revision changes `.gitattributes` only,
it overwrites the previous conversion result.
If `.gitattributes` gets deleted, the file produced from `.hgeol` is restored.

Note that the generated `.gitattributes` file will also control conversion of Mercurial files to their Git
representation during the repository conversion.

The user needs to review the resulting file and make necessary correction in future commits,
or by manually injecting the correct file at the appropriate revisions,
by using `<AddFile>` directives in the configuration file.

Ignoring files from Mercurial revision tree
----------------------------

Quite often, when a repository haven't been properly setup to ignore temporary files and build artifacts,
those files get committed by mistake. During Mercurial to Git conversion,
the program can ignore those files and drop them from the resulting Git commits.

To ignore files, use `<IgnoreFiles>` directives.
The directives can be present in `<Default>` or `<Project>` section, or in `<MapBranch>` section:

```xml
	<Project>
		<IgnoreFiles>glob pattern....</IgnoreFiles>
		......
		<MapBranch>
			<IgnoreFiles>glob pattern....</IgnoreFiles>
		</MapBranch>
	</Project>
```

The directive contains a semicolon-separated list of pathname patterns to ignore.
Multiple `<IgnoreFiles>` directives can be present.

If a pattern is prefixed with an exclamation mark '`!`',
it means this pattern is excluded from ignore (negative match).

First, glob patterns in the directive under `<MapBranch>` section are matched against paths.

Then glob patterns in the directive under `<Default>` or `<Project>` section are matched against paths.
All `<IgnoreFiles>` definitions from `<Default>` are processed *after* all sections in `<Project>`.

The program matches paths against each glob pattern in sequence, until a match is found.
If it's a negative match (the pattern is prefixed with '`!`'), the file is not ignored.

Ignored files are logged, with `IGNORED:` prefix.
If a whole directory is ignored, files under it are not printed separately.

Deleting files from the project tree
----------------------------

You can delete files (make them non-present in the resulting Git repository) at the given revision,
by using `<DeleteFile>` directive under `<Default>` or `<Project>` section.
You can delete files present in the original Mercurial repository, and also files injected by `<AddFile Path="path">` directive.
You cannot delete files injected by `<InjectFile Path="path">` directive.

```xml
	<Project>
		<DeleteFile Path="path"
				Rev="revision"
				RevId="Revision ID" />
	</Project>
```

`Path="path"` attribute specifies the file path in the repository tree.
`Rev="revision"` specifies the revision number at which the file is to be deleted.
`<RevId>revision ID</RevId>` specifies the revision string at which the file is to be deleted.
Only one `<Rev>` or `<RevId>` specification can be present.

Unlike `<IgnoreFiles>` directive, `<DeleteFile>` lets you delete a file at the specified revision.

Copying files and directories
---------------------------------

Sometimes you need to move a tree or a file into a directory you want it to be in your new Git repository.
Use `<CopyPath>` directive to perform a copy.
Note that this operation also creates a connection in the history from one place to another.

`<CopyPath>` directives can only be present in a `<Project>` section.
If it's present  under `<Default>` section, it's ignored.

```xml
	<Project>
		<CopyPath>
			<FromPath>source file/directory path</FromPath>
			<FromRev>source revision</FromRev>
			<FromRevId>source revision ID</FromRevId>
			<Path>target file/directory path</Path>
			<Rev>target revision</Rev>
			<RevId>target revision ID</RevId>
		</CopyPath>
	</Project>
```

`<RevId>revision ID</RevId>` and `<FromRevId>source revision ID</FromRevId>` specifies symbolic revision ID,
to which this specification applies.
Only one `<Rev>` or `<RevId>` specification can be present.
Only one `<FromRev>` or `<FromRevId>` specification can be present.

Forcing a merge
---------------

Occasionally, you want to join two lines of history left disjointed in the repository.

Use `<MergeBranch>` directive to create a connection from one repository revision to another revision.
Note that this operation doesn't change the files, it just links the Git commits by a parent.

`<MergeBranch>` directives can only be present in a `<Project>` section.
If it's present  under `<Default>` section, it's ignored.

```xml
	<Project>
		<MergeBranch>
			<FromRev>source revision</FromRev>
			<FromRevId>source revision ID</FromRevId>
			<Rev>target revision</Rev>
			<RevId>target revision ID</RevId>
		</MergeBranch>
	</Project>
```

`<RevId>revision ID</RevId>` and `<FromRevId>source revision ID</FromRevId>` specifies symbolic revision ID,
to which this specification applies.
Only one `<Rev>` or `<RevId>` specification can be present.
Only one `<FromRev>` or `<FromRevId>` specification can be present.

Changing file mode mask
-----------------------

Unlike Git, Mercurial doesn't keep Unix file mode.
To checkout files as executables, they can be assigned `executable` attribute in the repository.
Though, in mis-configured repositories, this attribute is often given to files not intended to be executable.

The program assigns file mode 100644 to regular files, unless they have `executable` attribute,
in which case they get file mode 100755.

Symbolic links get file mode 120000.

You can give a different file mode to regular files, or fix misconfigured `executable`,
by using `<Chmod>` specification under `<Default>` or `<Project>` section.

```xml
	<Project>
		<Chmod>
			<Path>glob pattern...</Path>
			<Mode>file mode</Mode>
		</Chmod>
	</Project>
```

Here **glob pattern** is a semicolon-separated list of patterns.
Negative patterns (do not match) should be prefixed with an exclamation mark '`!`'.
**file mode** is Unix file mode consisting of three octal digits (0-7).

All `<Chmod>` definitions from `<Default>` are processed *after* all sections in `<Project>`.

If a file path matches a pattern in the list, it's committed with the specified mode.

Typically, the following `<Chmod>` specifications need to be used:

```xml
	<Project>
		<Chmod>
			<Path>*.sh;*.pl;*.so;*.exe;*.dll;*.bat;*.cmd;*.EXE;*.DLL;*.BAT;*.CMD</Path>
			<Mode>755</Mode>
		</Chmod>
		<Chmod>
			<Path>*</Path>
			<Mode>644</Mode>
		</Chmod>
	</Project>
```

This forces all files with extensions `.sh`, `.pl`, `.exe`, `.dll`, `.bat`, `.cmd`, `.so` to have mode 100755,
and all other files to have mode 100644.
`.exe`, `.bat`, `.cmd` and `.dll` files here are forced to mode 100755 (executable),
because Git under Cygwin will otherwise check them out as non-executable, and then those files won't run.

Mapping Mercurial usernames{#Mapping-HG-usernames}
---------------------

Mercurial commits can store short usernames for commit authors, or name+email strings.
Git stores full names and emails.
To make pretty commits, the program uses a map file in JSON format.
It consists of multiple sections which map HG usernames to Name and Email attributes:

```json
{
	"<HG username>": {
		"Name": "<Git name>",
		"Email": "<email>"
	},
	....
}
```

For example:

```json
{
	"dvader": {
		"Name": "Darth Vader",
		"Email": "dvader@deathstar.example.com"
	},
	"luke.skywalker": {
		"Name": "Luke Skywalker",
		"Email": "lskywalker@tatooine.example.com"
	}
}
```

To tell the program to use an authors map JSON file, specify `--authors-map=<filename.json>` command line option.

If a Mercurial username is not mapped, the program will make an email as `<HG username>@localhost`,
same as Git does when `user.email` setting is not configured.

To make an initial author map file, specify `--make-authors-map=<filename.json>` command line option.
Note that the file will only contain usernames encountered while making Git commits on directories mapped to Git branches.
Then edit the produced file and use it as input for `--authors-map` option.

In a Mercurial repository, changesets (commits) may come with author name and email
combined into the changeset username, and even put in quotes sometimes.
The program parses the usernames, making an effort to separate the name and email.

Performance optimizations
--------------------------

To speed up the conversion, the program employs parallel processing, where appropriate.

First of all, current implementation of Python interpreter doesn't take full advantage of multiple threads,
because it uses the infamous Global Interpreter Lock (GIL). Only one thread interprets the bytecode at any time.

Yet, some functions, such as SHA1 calculations, can release the GIL temporarily and run truly in parallel with other threads.
Also, it can spawn other processes, such as Git, which will be also running in parallel.
Some Git operations, though, may have constraints on parallel operations.

The main thread reads the revisions from the repository and reconstructs the revision history into trees.
Necessary Git hashing operations are queued.
The program runs `git hash-object` operations by spawning up to 8 instances of Git.

Note that identical blobs introduced by different revisions are only run through `hash-object` once.
If different branches or revisions introduce same file contents, it doesn't add extra hashing overhead.
